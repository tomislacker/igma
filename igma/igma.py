import git.exc
import json
import os
import re
import subprocess
from git import Repo
from igma.util import LogProducer


class IPTTable(object):
    def __init__(self, name, generated_at=None):
        self.name = name
        self.generated_at = generated_at
        self.chains = {}

    def chain(self, chain_name):
        if chain_name not in self.chains.items():
            self.chains[chain_name] = IPTChain(chain_name)

        return self.chains[chain_name]

    def __repr__(self):
        return json.dumps({
            'name': self.name,
            'generated_at': self.generated_at,
            'chains': [
                {'name': chain.name, 'rules': chain.rules}
                for chain_name, chain in self.chains.items()
            ]
        })


class IPTChain(object):
    def __init__(self, name, default="-"):
        self.name = name
        self.default = default
        self.rules = []

    def add_rule(self, rule):
        self.rules.append(rule)

    def __repr__(self):
        return json.dumps({
            'name': self.name,
            'rules': self.rules
        })


class IGMA(LogProducer):
    IPTS_PATTERN_CHAIN = r'^:(?P<chain>.+)\s+(?P<default_rule>.+)\s+' \
                         r'\[(?P<packets>\d+):(?P<bytes>\d+)\]$'
    """Pattern for finding the :chain lines in iptables-save output"""

    IPTS_PATTERN_GENERATED = r'^#\s*Generated\s+by\s+(?P<program>.+)' \
                             r'\s+v(?P<version>.+)\s+on\s+(?P<datetime>.+)$'
    """Pattern for finding the 'generated by' line in iptables-save output"""

    IPTS_PATTERN_RULE = r'^-A\s+(?P<chain>[^\s]+)\s+(?P<rule>.*)$'
    """Pattern for finding rules lines in iptables-save output"""

    IPTS_PATTERN_TABLE = r'^\*(?P<table>.+)$'
    """Pattern for finding the *table lines in iptables-save output"""

    PRODUCTION_PATH = "/etc/igma"
    """Path to production firewall repository"""

    @classmethod
    def parse_table_dump(cls, lines):
        regex_table = re.compile(cls.IPTS_PATTERN_TABLE)
        table = None
        for line in lines:
            match = regex_table.match(line)
            if not match:
                continue
            table = IPTTable(match.groupdict()['table'])
            break

        if table is None:
            # @TODO Make named exception
            raise Exception("Could not find table name")

        regex_chain = re.compile(cls.IPTS_PATTERN_CHAIN)
        for line in lines:
            match = regex_chain.match(line)
            if not match:
                continue

            chain_name = match.groupdict()['chain']
            default = match.groupdict()['default_rule']
            chain = table.chain(chain_name)
            chain.default = default

        regex_rule = re.compile(cls.IPTS_PATTERN_RULE)
        for line in lines:
            match = regex_rule.match(line)
            if not match:
                continue

            rule_dict = match.groupdict()
            chain_name = rule_dict['chain']
            rule_body = rule_dict['rule']
            table.chain(chain_name).add_rule(rule_body)

        return table

    def __init__(self, path=None, ipt_save="iptables-save"):
        LogProducer.__init__(self, use_module_path=False)

        if not path:
            path = self.PRODUCTION_PATH

        self._path = path
        self._ipt_save = ipt_save
        self.use_sudo = (os.getuid() != 0)

        self._log.debug("Using path: {path}".format(path=self._path))
        self._log.debug("iptables-save: {path}".format(path=self._ipt_save))

        if not os.path.exists(self._path):
            self._log.debug("Creating path")
            os.mkdir(self._path)

        try:
            self.repo = Repo(self._path)
        except git.exc.InvalidGitRepositoryError:
            self._log.debug("Initializing repo")
            self.repo = Repo.init(self._path)

    def dump(self, tables=None):
        if not tables:
            tables = ["filter", "mangle", "nat"]

        for table in tables:
            table_path = os.path.join(self._path, table)
            self._dump_table(table, table_path)

    def _dump_table(self, table_name, table_path):
        if not os.path.isdir(table_path):
            self._log.debug("Creating table dir: {path}".format(
                path=table_path
            ))
            os.mkdir(table_path)

        dump_command = []
        if self.use_sudo:
            dump_command.append("sudo")

        dump_command += [self._ipt_save, "-t", table_name]
        self._log.debug("Dump command: {cmd}".format(cmd=dump_command))

        proc = subprocess.Popen(dump_command, bufsize=1,
                                stdout=subprocess.PIPE,
                                universal_newlines=True)
        lines = []
        while True:
            line = proc.stdout.readline()
            if len(line) == 0:
                break

            lines.append(line.strip())

        table = self.parse_table_dump(lines)
        chains_path = os.path.join(table_path, ".chains")
        with open(chains_path, "w") as output_file:
            for chain_name, chain in table.chains.items():
                output_file.write("{n} {j}\n".format(
                    n=chain.name,
                    j=chain.default
                ))

        for chain_name, chain in table.chains.items():
            chain_path = os.path.join(table_path, chain_name)
            with open(chain_path, "w") as output_file:
                for rule in chain.rules:
                    output_file.write(rule + "\n")

